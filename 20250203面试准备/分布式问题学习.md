1. **超卖问题及解决**：在并发场景下，商品库存扣减可能出现问题，如数据库 update 相互覆盖、库存扣减为负数等。单体应用可使用本地锁加数据库行锁解决；分布式应用则有数据库乐观锁、数据库维护锁表、Redis 的 setNX、zookeeper 的 watcher 机制、Redisson 和 curator 框架内的分布式锁等多种解决方式
2. **单体应用解决超卖的正确示例**：包括将事务包含在锁的控制范围内、使用 synchronized 的代码块、使用 Lock 等方式，确保在锁释放前事务已提交，避免超卖问题
3. **常见分布式锁的使用**：数据库乐观锁利用 version 字段和 CAS 实现，但并发量大时 update 失败率高；数据库分布式锁操作性能差且有锁表风险；Redis 的 setNx 利用单线程特性保证只有一个会话可设置成功；zookeeper 通过瞬时 znode 节点和 watcher 监听机制实现分布式锁；Curator 客户端提供了官方实现的分布式锁；Redisson 重新实现了 Java 并发包下的类，使其可跨 JVM 使用；Etcd 一般不用于普通项目的锁。
4. **常见分布式锁的原理**：Redisson 利用 lua 脚本实现原子操作，包含尝试加锁、锁续命、循环间隔抢锁、释放锁和唤醒其他线程、重入锁等逻辑；RedLock 基于多个独立 Redis Master 节点，通过多数节点加锁成功来获取锁，但存在持久化机制、主从架构、时钟跳跃等导致重复加锁的问题；Curator 的 InterProcessMutex 是可重入锁。
5. **业务中使用分布式锁的注意点**：获取的锁要设置有效期，避免死锁；释放锁时要判断锁对应的 value 并使用 lua 脚本实现原子 del 操作；可通过锁续命解决锁提前过期问题；还可采用分段加锁逻辑提升分布式锁性能。
6. **分布式锁的真相与选择**：分布式锁需满足互斥、超时机制、完备的锁接口、可重入性、公平性等特性，但正确性与性能存在权衡。数据库分布式锁一般不考虑；Redis 适用于高并发、高性能场景；Redisson 常用于分布式场景；Zookeeper 适用于高可靠、并发量不太高的场景；Curator 提供了锁的方法；Etcd 安全可靠但较重。不推荐自己编写分布式锁，建议使用 Redisson 和 Curator 实现的分布式锁
7. **分布式锁的必要性**：在多线程或同一机器不同进程操作共享资源时，单机锁可实现互斥。但在分布式场景下，不同机器的进程操作共享资源时，单机锁无法满足需求，需引入分布式锁。Redis 因性能优势常被用于实现分布式锁12。
8. Redis 分布式锁的实现与问题
   - **基本实现**：利用 Redis 的 SETNX 命令，若 key 不存在则设置值，实现互斥加锁；通过 DEL 命令释放锁。但这种方式存在死锁风险，如业务异常或进程挂掉未释放锁。
   - **问题及解决**：死锁问题可通过在业务代码异常处理中释放锁以及给锁设置过期时间解决；锁过期时间难以准确预估，可采用守护线程定时续期（如 Redisson 库的 “看门狗” 线程）；为避免释放别人的锁，加锁时设置唯一标识，释放锁时通过 Lua 脚本保证判断和删除操作的原子性。
9. Redis 主从同步与 Redlock 方案
   - **主从同步影响**：Redis 主从集群模式下，主从复制异步，主库加锁后未同步到从库就宕机，可能导致锁丢失。
   - **Redlock 方案**：部署至少 5 个独立主库实例，客户端依次向多个实例加锁，多数（≥3 个）加锁成功且总耗时小于锁过期时间才算加锁成功，释放锁时操作所有节点。该方案通过多实例加锁容错，多数成功保证正确性，计算耗时避免锁失效，操作所有节点清理残留锁。
10. Redlock 的争论
    - **Martin 的质疑**：认为 Redlock 对追求效率而言太重，对正确性而言不够安全。分布式系统存在网络延迟、进程暂停、时钟漂移等问题，Redlock 依赖时钟同步，时钟异常会导致锁失效，且无法提供类似 fencing token 的方案保证正确性。
    - **Redis 作者的反驳**：Redlock 对时钟精度要求不高，允许一定误差，且时钟问题可通过运维避免。Redlock 在加锁过程中能检测出网络延迟、进程 GC 等问题，若在拿到锁之后出现异常，多种锁服务都无法解决。同时质疑 fencing token 机制，认为其对资源服务器要求高，且 Redlock 的随机值可实现类似功能。
11. ZooKeeper 和 Etcd 的分布式锁
    - **ZooKeeper 分布式锁**：客户端通过创建临时节点实现加锁，连接不断则一直持有锁，异常崩溃时临时节点自动删除释放锁。但存在 GC 或网络延迟时，客户端心跳受阻，锁可能被误释放，导致冲突。
    - **Etcd 分布式锁**：利用租约概念，创建租约并与节点关联，定时续期保持锁有效。同样在遇到 GC 或网络延迟时，租约无法续期，锁会被删除，引发冲突。
12. **总结与建议**：任何基于 Redis、ZooKeeper 或 Etcd 实现的分布式锁在极端情况下都无法保证 100% 安全。使用 Redis 分布式锁可阻挡高并发请求，但对数据敏感业务，资源层需借鉴 fencing token 方案兜底，结合两者满足多数业务场景需求
13. 分布式锁的必要性与属性
    - **必要性**：为提升效率，协调客户端避免重复工作；保证操作正确性，防止数据不一致、丢失等严重问题。
    - **属性**：具备互斥性，同一时刻仅一个客户端可持有锁；需避免死锁，常通过设置 TTL 实现；要有容错性，可采用锁服务集群或客户端多请求方式。
14. 常见实现方案
    - **Redis**：基于 Redis 实现分布式锁时，错误加锁方式如使用非原子操作的 SETNX 和 EXPIRE 命令易出现问题。正确加锁应使用 SET 命令并设置随机字符串 requestId 保证唯一性，释放锁时用 Lua 脚本保证原子性，还可通过 TimerTask 类或 Redisson 框架的 watchdog 机制解决锁超时问题。但 Redis 主从架构存在数据同步复制问题，Redlock 算法虽基于多个 Master 节点提高容错性，但也存在一些问题，如依赖系统时钟、客户端长期阻塞和时钟跳跃可能导致锁失效。
    - **MySQL**：使用 ShedLock 需创建加锁表，通过插入或更新操作抢锁，释放锁则通过设置 lock_until 实现。不过存在单点问题和主从同步性能问题78。
    - **ZooKeeper**：利用其临时顺序节点实现分布式锁，通过 watch 机制实现等待锁释放通知，具有公平性且能自动释放锁。但存在惊群效应，客户端长时间 GC 等情况可能导致多个客户端同时获取锁，适用于并发量不高的场景。
15. **Chubby**：Google 的分布式锁服务，与 ZooKeeper 类似。通过 sequencer 机制和锁延期机制（lock-delay）缓解锁失效问题，引入资源方和锁服务的验证保障锁安全性。
16. **总结**：不同分布式锁方案适用于不同场景，选择时需综合考虑业务对极端情况的容忍度、设计复杂度和收益等因素