**1****、自我介绍****;**

结合简历中的个人情况，项目履历，特长方面自由发挥

**2****、以前做的是那块的业务****,****对信贷哪一块比较熟悉****?**

信贷分几大块：

贷前（企业客户信息创建、准入、评级，个人客户信息创建、评分；授信、额度管理等）

贷中（业务申请审批；押品管理；合同管理；放款支付管理等）

贷后（贷后检查；贷后变更；还款管理；分类调整；预警；资产保全；资产证券化等）

通用功能（产品组件配置、工作流配置、规则配置等）

具体做哪块业务，根据自己实际情况自由发挥。一定找自己相对熟悉的功能点展开叙述。

3、sso登录认证走的是哪个协议？机制流程是怎样的？

OAuth,通过access_token进行交互,

Client向资源所属者发起一个授权请求，资源所属者输入相应的认证信息，将授权返回给client;

client再将获取到的授权信息请求授权服务器，并返回access token;

client然后就可以拿着这个access token去请求资源服务器，最后获取到受限资源。

4、springmvc加载的顺序？流程说一下？

web容器启动的时候，SpringMVC配置的ContextLoadListener将会被启动，ContextLoadListener会被触发初始

化事件，执行initWebApplicationContext方法；

创建好Context实例后，执行configureAndRefreshWebApplicationContext方法。非常重要的一点，这里会

loadParentContext,并且加载ApplicationContext中的bean 资源文件。

configureAndRefreshWebApplicationContext方法会执行Context的refresh方法,初始化bean,实例化bean,最后，

finishRefresh方法会发布Context刷新完成的事件.

**5****、****mysql****用的比较多吗？它的性能调优是用哪个命令去查看有没有命中索引？**

根据自己情况回答使用是否频繁

通过explain 该命令查看SQL执行计划，分析sql是否命中索引.

**6****、****redis****用的有哪几种？**

**单机****:**采用单个 Redis 节点部署架构，没有备用节点实时同步数据，不提供数据持久化和备份策略，适用于数据可

靠性要求不高的纯缓存业务场景;

**主从****:**采用主从（replication）部署结构，相较于单副本而言最大的特点就是主从实例间数据实时同步，并且提供数

据持久化和备份策略,可对完提供读写分离;

**哨兵****:**其部署架构主要包括两部分：Redis Sentinel 集群和 Redis 数据集群;其中 Redis Sentinel 集群是由若干

Sentinel 节点组成的分布式集群，可以实现故障发现、故障自动转移、配置中心和客户端通知。Redis Sentinel 的

节点数量要满足 2n+1（n>=1）的奇数个

集群:当遇到单机内存，并发和流量等瓶颈的时候，Redis Cluster 能起到很好的负载均衡的目的,去中心化.**7****、业务模块主要是做的审批模块吗？**

这个问题主要问业务审批流程：业务模块的大页面信息很多，是必要的审批模块。

就是确认审批客户贷款相关信息，包括引客户基本信息、信贷产品、业务类型、担保信息、贷款要素信息、其他各

类业务要素等；

大体审批流程：根据不同分支行业务和审批权限走一个初步审批流程，流程中根据规则判断风险，由风控部门介入

确认。业务模块审批完，后续还有合同签署管理流程、放款流程。

**8****、做的项目技术栈都有什么**

结合简历中的项目技术栈，自由描述与发挥

**9****、对****springboot****的理解；**

Spring Boot可以轻松创建独立的生产级基于Spring的应用程序,只要通过 “just run”（可能是run ‘Application’或

java -jar 或 tomcat 或 maven插件run 或 shell脚本）便可以运行项目。大部分Spring Boot项目只需要少量的配置

即可。开发基于Spring的应用程序很容易

SpringBoot项目所需的开发或工程时间明显减少，不需要编写大量的样板代码，xml配置和注释。可以容易地与

Spring生态系统集成，SpringJDBC、SpringORM，SpringData，SpringSecurity等，提供嵌入式的HTTP服务器，

Tomcat和Jetty，可以轻松的开发和测试web应用程序等

**10****、****springboot****是如何处理****maven****依赖冲突问题的；**

第一种，将新加的依赖包中的冲突的依赖排除掉，这样就是使用项目中原来的依赖的版本；

第二种，指定一个所有依赖都可以使用的依赖版本，所有依赖此依赖的依赖都是用这一版本的依赖；

第三种，调整依赖的顺序，因为Maven的规则是优先顺序扫描，同时以扫描到的第一个依赖版本为准，因

此，调整依赖的顺序可以调整使用哪一个包中的依赖版本；

**11****、****java****锁的理解；**

自旋锁 ：是指当一个线程在获取锁的时候，如果锁已经被其他线程获取，那么该线程将循环等待，然后不断判断锁

是否能够被成功获取，直到获取到锁才会退出循环。 例如：CAS在for循环的应用

乐观锁 ：假定没有冲突，在修改数据时如果发现数据和之前获取的不一致，则读最新数据，修改后重试修改。 例

如：CAS

悲观锁 ：假定会发生并发冲突，同步所有对数据的相关操作，从读数据就开始上锁。

独享锁（写） ：给资源加上写锁，拥有该锁的线程可以修改资源，其他线程不能再加锁（单写）。

共享锁（读） ：给资源加上读锁后只能读不能改，其他线程也只能加读锁，不能加写锁 （多读）。

可重入锁 ：线程拿到一把锁后，可以自由进入同一把锁所同步的代码。

不可重入锁 ：线程拿到一把锁后，不可以自由进入同一把锁所同步的代码。

公平锁 ：争抢锁的顺序，按照先来后到的顺序。

非公平锁 ：争抢锁的顺序，不按照先来后到的顺序。

**12****、创建线程的方式和各自的区别；**

继承Thread类实现Runnable接口

实现Callable接口

三种方式的优缺点

采用继承Thread类方式：

（1）优点：编写简单，如果需要访问当前线程，无需使用Thread.currentThread()方法，直接使用this，即可获得

当前线程。

（2）缺点：因为线程类已经继承了Thread类，所以不能再继承其他的父类。

采用实现Runnable接口方式：

（1）优点：线程类只是实现了Runable接口，还可以继承其他的类。在这种方式下，可以多个线程共享同一个目

标对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU代码和数据分开，形成清晰的模

型，较好地体现了面向对象的思想。

（2）缺点：编程稍微复杂，如果需要访问当前线程，必须使用Thread.currentThread()方法。

Runnable和Callable的区别：

(1)Callable规定的方法是call(),Runnable规定的方法是run().

(2)Callable的任务执行后可返回值，而Runnable的任务是不能返回值得

(3)call方法可以抛出异常，run方法不可以，因为run方法本身没有抛出异常，所以自定义的线程类在重写run的时

候也无法抛出异常

(4)运行Callable任务可以拿到一个Future对象，表示异步计算的结果。它提供了检查计算是否完成的方法，以等待

计算的完成，并检索计算的结果。通过Future对象可以了解任务执行情况，可取消任务的执行，还可获取执行结

果。

 start（）和run（）的区别

start()方法用来，开启线程，但是线程开启后并没有立即执行，他需要获取cpu的执行权才可以执行

run()方法是由jvm创建完本地操作系统级线程后回调的方法，不可以手动调用（否则就是普通方法）

**13****、****springboot****常用注解有哪些；**

一：ComponentScan ： 作用扫描

二：MapperScan ： 扫描mapper 

三：@SpringBootApplication 组合注解

四：@EnableAutoConfiguration 开启自动配置的功能

五：@AutoConfigurationPackage

@ImportAutoConfiguration 导入配置类，一般做测试的时候使用，正常优先使用@EnableAutoConfiguration 这

个注解是自动配置包

@Autowired 注入Service

@RestController表示这是个控制器 bean。

九：@Configuration  一般用来声明配置类@Service: 注解在类上，表示这是一个业务层bean

@Controller：注解在类上，表示这是一个控制层bean

@Repository: 注解在类上，表示这是一个数据访问层bean

@Component：注解在类上，表示通用bean ，value不写默认就是类名首字母小写

@Transactional：事务注解

**14****、对工作流的理解**

工作流是将一组任务组织起来的完成某个经营过程。在工作流中定义了触发的任务和触发的条件。每个任务可以有

一个或多个软件系统完成，也可以由一人或一组完成。还可以由一人或多人与软件系统完成。任务的触发顺序和触

发条件用来定义并实现任务的触发、任务的同步和信息流（数据流）的传递，常用的有Activiti工作流

**15****、****oracle****与****mysql****换行。**

mysql:group_concat 函数实现拼接, 排序连接

select u.age,group_concat(u.name order by t.name desc)  as NameStr from user u group by u.age;

会根据 名字排序 ，升序 去掉 desc;

oracle:wm_concat 函数实现拼接

/简单的合并同一个同学的课程/

select stuid,wm_concat(coursename)

from stu_score

group by stuid

**16****、****mybatis****的****#****与****$****区别。**

**{}** **是预编译处理**

You can't use 'macro parameter character #' in math mode

**{}** **把** **${}****替换成 变量值，****#{}** **可以防止****sql****注入 ，**

**提高安全性**

**17****、****sql****优化。**

在表中建立索引，优先考虑where、group by使用到的字段

尽量避免使用select *，返回无用的字段会降低查询效率

尽量避免使用or，in 和not in，在字段开头模糊查询，避免进行null值的判断，会导致数据库引擎放弃索引进行全

表扫描

当数据量大时，避免使用where 1=1的条件

**18****、存储过程怎么调试。以及游标的作用。**存储过程是一个预编译的SQL语句，优点是允许模块化的设计，就是说只需创建一次，以后在该程序中就可以调用

多次。

优点：

1）存储过程是预编译过的，执行效率高。

2）存储过程的代码直接存放于数据库中，通过存储过程名直接调用，减少网络通讯。

3）安全性高，执行存储过程需要有一定权限的用户。

4）存储过程可以重复使用，可减少数据库开发人员的工作量。

一般存储过程调试通过plsql进行，或者增加日志输出，快速定位存储过程问题。

游标用来标识你在的数据库中位置，因为你每次打开数据库的时候都有个指针，你读一便数据库，其实就是指针遍

历数据库一周，而游标就是指针。

**19****、****springboot****常用注解。以及自动配置流程。**

一：ComponentScan ： 作用扫描

二：MapperScan ： 扫描mapper 

三：@SpringBootApplication 组合注解

四：@EnableAutoConfiguration 开启自动配置的功能

五：@AutoConfigurationPackage

@ImportAutoConfiguration 导入配置类，一般做测试的时候使用，正常优先使用@EnableAutoConfiguration 这

个注解是自动配置包

七：@Autowired 注入Service

@RestController``表示这是个控制器 bean 。

九：@ Configuration 一般用来声明配置类

@Service:

注解在类上，表示这是一个业务层bean

@Controller：

注解在类上，表示这是一个控制层bean

@Repository:

注解在类上，表示这是一个数据访问层bean

@Component：

注解在类上，表示通用bean ，value不写默认就是类名首字母小写

@Transactional：事务注解

Spring Boot启动的时候会通过@EnableAutoConfiguration注解找到META-INF/spring.factories配置文件中的所有

自

动配置类，并对其进行加载，而这些自动配置类都是以AutoConfiguration结尾来命名的，它实际上就是一个JavaConfig形式的Spring容器配置类，它能通过以Properties结尾命名的类中取得在全局配置文件中配置的属性

如：

server.port，而XxxxProperties类是通过@ConfigurationProperties注解与全局配置文件中对应的属性进行绑定

的。

**20****、前端报****404****，排查错误**

1、前端或后端url值单词拼写错误

2、刚改完代码，系统还在热部署的过程中，就切到浏览器刷新页面了。

3、请求方法忘记写@Response注解，请求方法本来想返回一个json字符串，结果被框架认为是想去找以json为命

名的视图（view），发生http404 

4、前端在文件结构复杂的情况下使用**相对自身**的相对路径，而不是**相对****web****根目录**的相对路径时，很容易把url路

径搞错。

**21****、****redis****的常用数据类型。用****Hash****的场景**

字符串(String)

字符串列表(list):可以实现队列和堆栈

字符串集合(set):可以获取交集,并集,差集

哈希(hash)

有序的字符串集合(sorted set):可以实现排行榜功能

使用Hash的场景为电商中的购物车，或者对象存储的数据

**22****、整个信贷项目整体流程是否熟悉？**

问的项目实施工艺？

需求确认-分析设计-开发-测试-投产，信贷项目涉及功能模块多，业务产品多，对接业务部门多，外部关联系统

多，实施过程中层层环节。

安排好分组，控制好每人负责事项。涉及要展开讲的比较多，面试者可以发撒一下自己思维。

如果是问的信贷整体流程？

围绕一笔贷款，把贷前-贷中-贷后要做的事情梳理清楚，一笔贷款的全生命周期。

**23****、信贷系统和哪些业务系统进行交互**

主要对接交互系统，不同行系统对接不一样，以下作为参考：

核心系统：账户账号查询、放款、还款、登账等；

ECIF客户信息系统：获取客户号，同步客户信息等；

征信系统：查询征信报告；

二代支付系统：行外账号支付接口；

集中作业平台：业务申请，客户、业务等信息集中录入平台；

影像文件平台：影像资料上传，下载查阅；

票据系统：提供额度查询，并把票据业务推送同步票据系统；国结系统：提供额度查询，并把福费廷等国结业务推送同步国结系统；

供应链系统：提供额度查询，并把供应链产品业务推送同步供应链系统；

OCR、短信、统一门户等。

**24****、你的简历上显示你熟悉****XXX****技术，可以具体说一下么？**

结合简历中熟悉XXX技术，自由发挥

**25****、****oracle****熟悉到什么程度？**

根据自己的熟悉程度进行描述

**26****、前端****JS****会用么？****Jquery****会用么？**

根据自己的熟悉程度进行描述

**27****、你的优势是什么？**

详细说出自己的亮点,然后描述该亮点为公司带来了什么

**28****、你是计算机专业毕业的么？考了哪些计算机相关的证书？**

结合简历中的信息，自由发挥

**29****、算法、排序熟悉么？**

常见算法,冒泡,二分,快排,二叉树

**30****、****java****数据类型有哪些** **8****个**

逻辑型boolean，文本型char，整数型(byte、short、int、long)，浮点型(float、double)

**31****、****String****类型能被继承么 为什么？**

不能被继承，因为String类有final修饰符，而final修饰的类是不能被继承的。

**32****、用过****stringbuffer****么 说说区别 再说说****Stringbudder****的区别**

用过，stringbuffer是线程安全的，因为对方法加了同步锁或者对调用的方法加了同步锁

而StringBudder：并没有对方法进行加同步锁，所以是非线程安全的

单线程操作字符串缓冲区 下操作大量数据 ：StringBuilder

多线程操作字符串缓冲区 下操作大量数据 ： StringBuffer

**33****、说说** **hashMap** **与****hastable**

 HashMap不是线程安全的，HashMap是map接口的子类，是将键映射到值的对象，其中键和值都是对象，并且

不能包含重复键，但可以包含重复值。HashMap允许null key和null value，而hashtable不允许。

HashTable是线程安全。HashMap是Hashtable的轻量级实现（非线程安全的实现），他们都完成了Map接口，主

要区别在于HashMap允许空（null）键值（key）,由于非线程安全，效率上可能高于Hashtable。

**34****、****hashMap****底层扩容机制** **put****过程**当hashmap中的元素个数size超过数组长度*loadFactor*时，就会进行数组扩容，*loadFactor*的默认值为*0.75*，也就

是说，默认情况下，数组大小为*16*，那么当*hashmap*中元素个数超过*16*0.75=12的时候，就把数组的大小扩展为

2*16=32，即扩大一倍，然后重新计算每个元素在数组中的位置。

put过程，HashMap会对put的数据对key.hashCode高位与运算， 如果tab数组为空，进行resize()操作，计算tab

索引位置是否有值；没有值，直接插入；然后进行计算tab大小是否超过扩容。判断hash是否相等 && 调用equal()

判断key是否相等；相同，则更新原值, jdk1.8之后扩容采取尾插的方式,来避免死锁问题.

**35****、****“==”****与** **equals** **的区别**

== 对于基本类型来说是值比较，对于引用类型来说是比较的是引用；而 equals 默认情况下是引用比较，只是很多

类重新了 equals 方法，比如 String、Integer 等把它变成了值比较，所以一般情况下 equals 比较的是值是否相

等。

**36****、****arraylist****与****linkdslist****区别**

\1. 存储结构不同

Arraylis可以看作是能够自动增长容量的数组，存储结构是动态数组，linkedlist存储结构是双向链表

\2. 效率不同

查找效率Arraylist高于linkedlist，增加、删除linkedlist高于Arraylist

**37****、接口及抽象类的了解**

**实现**：抽象类的子类使用 extends 来继承；接口必须使用 implements 来实现接口。

**构造函数**：抽象类可以有构造函数；接口不能有。

**实现数量**：类可以实现很多个接口；但只能继承一个抽象类【java只支持单继承】。

**访问修饰符**：接口中的方法默认使用 public 修饰；抽象类中的抽象方法可以使用Public和Protected修饰。

接口中除了static、final变量，不能有其他变量，而抽象类中则不一定

**设计层面**：抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为的规范。

**38****、****java****类允许多继承么 接口允许多实现么 接口允许继承接口么**

JAVA类单继承：一个类只能继承一个类

接口允许多继承：一个接口可以继承多个类，一个类可以实现(implements)多个接口

接口允许继承接口

**39****、重载与重写的区别 重写方法上加注解是什么**

1.重载

发生在同一个类里；方法名相同，参数列表(包括个数、类型、顺序)不同

注：与返回值和异常声明无关

2.重写

发生在继承体系中；子类重写父类(包括直接父类、间接父类)中的方法；方法签名(包括方法名，参数列表)相同；可

用@Override注解强制编译器检查

注：

关于返回值如果返回值为基本数据类型或void,则返回值类型必须与父类中的相同

如果返回值为引用类型，则返回值必须为父类中返回值类型或其子类

@Override

**40****、继承和多态的理解 多态的三个特性**

继承

从已知的一个类中派生出一个新类，叫做子类。子类实现了父类所有非私有化的属性和方法，并根据实际需求扩展

出新的行为。

继承的优点：

1、继承是传递的，易于基础上的构造和扩充。

2、简化对事物的描绘，使层次更加清晰。

3、减少代码冗余。

4、提高可维护性。

多态

面向对象而言，多态分为编译时多态和运行时多态。

编译时多态是静态的，主要是指方法的重载（方法名相同，参数不同，返回值可以相同或者不同）。

运行时多态的动态的，一般由动态绑定实现。

多态只有在程序运行时才能知道引用变量所指的具体实例对象。

多态三大特征，子类继承父类，子类重写父类，父类指向子类。

**41****、****java****程序的运行步骤**

java程序实现了安全性,通过双亲委派的机制进行类加载,

当某个类加载器需要加载某个 .class 文件时，它首先把这个任务委托给他的上级类加载器，递归这个操作，如果

上级的类加载器没有加载，自己才会去加载这个类

**双亲委派机制的作用**

1、防止重复加载同一个 .class 。通过委托去向上面问一问，加载过了，就不用再加载一遍。保证数据安全。

2、保证核心 .class 不能被篡改。通过委托方式，不会去篡改核心 .clas ，即使篡改也不会去加载，即使加载也

不会是同一个 .class 对象了。不同的加载器加载同一个 .class 也不是同一个 Class 对象。这样保证了 Class 执

行安全。

**42****、软件工程专业 对算法都知道那些**

常见算法,冒泡,二分,快排,二叉树

**43****、数据库三大泛式**

**1****．********第一范式(确保每列保持原子性)**第一范式是最基本的范式。如果数据库表中的所有字段值都是不可分解的原子值，就说明该数据库表满足了第一范

式。

**第二范式********(确保表中的每列都和主键相关)**

第二范式在第一范式的基础之上更进一层。第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键

的某一部分相关（主要针对联合主键而言）。也就是说在一个数据库表中，一个表中只能保存一种数据，不可以把

多种数据保存在同一张数据库表中。

**第三范式****(****确保每列都和主键列直接相关****,****而不是间接相关****)**

第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。

**44****、说****spring****两个基本特性**

**45****、依赖注入方式有哪几种**

属性注入,常用的**@Autowired****方式进行属性注入****,**另外也有 @Resource 以及 @Inject 等注解，都可以实现

注入

set 方法注入:注入太过于臃肿，实际上很少使用

构造方法注入:如果类只有一个构造方法，那么 @Autowired 注解可以省略；如果类中有多个构造方法，那么

需要添加上 @Autowired 来明确指定到底使用哪个构造方法

**46****、项目中常用注解**

一：ComponentScan ： 作用扫描

二：MapperScan ： 扫描mapper 

三：@SpringBootApplication 组合注解

四：@EnableAutoConfiguration 开启自动配置的功能

五：@AutoConfigurationPackage

@ImportAutoConfiguration 导入配置类，一般做测试的时候使用，正常优先使用@EnableAutoConfiguration 这

个注解是自动配置包

七：@Autowired 注入Service

@RestController``表示这是个控制器 bean 。

九：@ Configuration 一般用来声明配置类

@Service:

注解在类上，表示这是一个业务层bean

IoC（控制反转）是Spring的一个 **容器** ，他 **不是一种技术** ，而 **是一种思想** ，依旧是基于面

向对象编程的。它能指导我们怎么样设计出松耦合、更优良的程序

AOP（面向接口编程），同样的，他也是一种思想，而不是技术。和OOP（面向对象编程）相比较，AOP是对OOP的补

充。OOP是静态的抽象，而AOP是动态的抽象。关于AOP的概念，简单来说就是将一个工程中与源代码无关，但是很多地方

都要用，抽出来也不影响源代码上下文的那一部分代码抽出来，然后要用的时候就织入进去，进行使用，至于是在指定

的代码之前使用还是之后又或者异常使用等，可以动态的进行.@Controller：

注解在类上，表示这是一个控制层bean

@Repository:

注解在类上，表示这是一个数据访问层bean

@Component：

注解在类上，表示通用bean ，value不写默认就是类名首字母小写

@Transactional：事务注解

**47****、****springmvc** **前端到后台处理 流程说下**

1、请求被web 容器接收，并且根据contextPath将请求发送给DispatcherServlet

2、DispatcherServlet接收到请求后，会设置一些属性（localeResolver、themeResolver等等），在根据request

在handlerMappings中查找对应的HandlerExecutionChain；然后根据HandlerExecutionChain中的handler来找

到HandlerAdapter，然后通过反射来调用handler中的对应方法（RequestMapping对应的方法）

3、handler就是对应的controller，调用controller中的对应方法来进行业务逻辑处理，返回ModelAndView（或者

逻辑视图名称）

4、ViewResolver根据逻辑视图名称、视图前后缀，来获取实际的逻辑视图

5、获取实际视图之后，就会使用model来渲染视图，得到用户实际看到的视图，然后返回给客户端。

**48****、****spring****的缺点**

**（一）重量级框架**

我们看到 Spring 架构图时会发现 Spring 里面包含有很多其他组件，比如数据访问、MVC、事务管理、面向切点、

WebSocket 功能等，因此这么复杂的组件集中到一起就会提高初学者的学习成本。还有一方面随着你的服务越

多，那么 Spring 的启动就会变得越慢。

**（二）集成复杂**

比如我们想要使用 MyBatis 或者 MongoDB的时候，我们要做很多工作不管使用配置方式也好还是使用注解方式。

**（三）配置复杂**

在使用 Spring 的时候，我们更多可能是选择 XML 进行配置，但目前这种配置方式已不在流行。

**（四）构建和部署复杂**

启动 Spring 的 IOC 容器，是完全要依赖于第三方的 web 服务器。自身不能启动的。

**49****、****springboot****的****javaconfig****配置**

Java配置方式就是使用Java类来替代Spring原先的xml文件,主要依赖于@Confuration和@Bean注解实现

@Confuration：使用在类上，说明该类是一个配置类相当于一个xml文件

@Bean：使用在方法上，作用是返回对象将对象保存在IOC容器中相当于XML文件中的bean标签

**50****、****”****因学校学过****jsp“** **说说****jsp****的****9****大内置对象**

out（JspWriter）：等同与response.getWriter()，用来向客户端发送文本数据；config（ServletConfig）：对应“真身”中的ServletConfig；

page（当前JSP的真身类型）：当前JSP页面的“this”，即当前对象；

pageContext（PageContext）：页面上下文对象，它是最后一个没讲的域对象；

exception（Throwable）：只有在错误页面中可以使用这个对象；

request（HttpServletRequest）：即HttpServletRequest类的对象；

response（HttpServletResponse）：即HttpServletResponse类的对象；

application（ServletContext）：即ServletContext类的对象；

session（HttpSession）：即HttpSession类的对象，不是每个JSP页面中都可以使用，如果在某个JSP页面中设置

<%@page session=”false”%>，说明这个页面不能使用session。

**51****、说说转发和重定向**

forward 是转发 和 redirect 是重定向：

地址栏 url 显示：foward url 不会发生改变，redirect url 会发生改变

**52****、****jsp****里有动态的****include****和静态的****include****是什么**

动态 INCLUDE 用 jsp:include 动作实现 jsp:include page="included.jsp" flush="true" / 它总是会检查所含文件中

的变化 , 适合用于包含动态页面 , 并且可以带参数。各个文件分别先编译，然后组合成一个文件。

静态 INCLUDE 用 include 伪码实现 , 定不会检查所含文件的变化 , 适用于包含静态页面 %@ include file="include

d.htm" % 。先将文件的代码被原封不动地加入到了主页面从而合成一个文件，然后再进行翻译，此时不允许有相

同的变量。

**53****、****Servlet****和****jsp****的区别**

\1. jsp经编译后就变成了Servlet.(JSP的本质就是Servlet，JVM只能识别java的类，不能识别JSP的代码,Web容器

将JSP的代码编译成JVM能够识别的java类)

\2. jsp更擅长表现于页面显示,servlet更擅长于逻辑控制.

\3. Servlet中没有内置对象，Jsp中的内置对象都是必须通过HttpServletRequest对象，HttpServletResponse对

象以及HttpServlet对象得到.

\4. Jsp是Servlet的一种简化，使用Jsp只需要完成程序员需要输出到客户端的内容，

**54****、****Servlet****生命周期 默认请求是****get****还是****post**

（1）加载和实例化

当Servlet容器启动或客户端发送一个请求时，Servlet容器会查找内存中是否存在该Servlet实例，若存在，则直接

读取该实例响应请求，直接进入步骤（3）；如果不存在，就通过构造方法创建一个Servlet实例。

（2） 初始化

实例化后，Servlet容器将调用Servlet的 init() 方法进行初始化（一些准备工作或资源预加载工作）。

（3）服务

初始化后，Servlet处于能响应请求的就绪状态。当接收到客户端请求时，调用service() 的方法处理客户端请求，

HttpServlet的service()方法会根据不同的请求 转调不同的doXxx()方法：doGet()和doPost()。

（4）销毁重新发布项目，正常关闭tomcat时，会执行destroy() 方法，如果非正常关闭，相当于程序中断，不会执行方法。

**55****、****jsp****的四个作用域**

Page作用域：代表变量只能在当前页面上生效；

Request：指从http请求到服务器处理结束，返回响应的整个过程。

Session：有效范围当前会话，从浏览器打开到浏览器关闭这个过程。

Application：代表变量能一个应用下(多个会话)，在服务器下的多个项目之间都能够使用。

**56****、****mybaits****解决 循环依赖怎么解决**

mybatis 的循环依赖，即是mapper.xml里面的A查询的resultMap包含了B属性（B属性是通过子查询得到的），而

B属性中又包含了A（B查询的resultMap中又包含了A的查询），就会造成A-B-A的情况。

底层是通过缓存+延迟加载的方式解决循环依赖,和spring解决循环依赖的思路大致相同,若想深入,可进入代码层.

**57****、****mybaits** **怎么防止****sql****注入的**

在编写MyBatis的映射语句时，尽量采用“**#**{xxx}”这样的格式。若不得不使用“**$**{xxx}”这样的参数，要手工地做好过

滤工作，来防止SQL注入攻击

**58****、****hibernate****三种状态**

临时状态(Transient):

当new一个实体对象后,这个对象处于临时状态,即这个对象只是一个保存临时数据的内存区域,如果没有变量引用这

个对象,则会被jre垃圾回收机制回收.这个对象所保存的数据与数据库没有任何关系,除非通过Session的save或者

SaveOrUpdate把临时对象与数据库关联,并把数据插入或者更新到数据库,这个对象才转换为持久对象.

持久状态(Persistent):

持久化对象的实例在数据库中有对应的记录,并拥有一个持久化表示（ID）.对持久化对象进行delete操作后,数据库

中对应的记录将被删除,那么持久化对象与数据库记录不再存在对应关系,持久化对象变成临时状态.持久化对象被修

改变更后,不会马上同步到数据库,直到数据库事务提交.在同步之前,持久化对象是脏的（Dirty）.

游离状态(Detached)：

当Session进行了Close、Clear或者evict后,持久化对象虽然拥有持久化标识符和与数据库对应记录一致的值,但是因

为会话已经消失,对象不在持久化管理之内,所以处于游离.游离状态的对象与临时状态对象是十分相似的,只是它还含

有持久化标识.

**59****、****Servlet****生命周期**

（1）加载和实例化

当Servlet容器启动或客户端发送一个请求时，Servlet容器会查找内存中是否存在该Servlet实例，若存在，则直接

读取该实例响应请求，直接进入步骤（3）；如果不存在，就通过构造方法创建一个Servlet实例。

（2） 初始化

实例化后，Servlet容器将调用Servlet的 init() 方法进行初始化（一些准备工作或资源预加载工作）。

（3）服务初始化后，Servlet处于能响应请求的就绪状态。当接收到客户端请求时，调用service() 的方法处理客户端请求，

HttpServlet的service()方法会根据不同的请求 转调不同的doXxx()方法：doGet()和doPost()。

（4）销毁

重新发布项目，正常关闭tomcat时，会执行destroy() 方法，如果非正常关闭，相当于程序中断，不会执行方法。

**60****、后台运行正常前台****404****是如何造成的**

**原因**:后台有 return

return的值会作为http请求的一个页面 所以肯定会报找不到错误

解决

\1. 直接去掉return,没有页面跳转可以不用return,要向前台传值可以用 out.println(1); 或

response.getWriter().print("2");

\2. 添加@ResponseBody注解 它的作用是 把你return的值作为http的内容返回，就是返回json数据，不跳转页

面

**61****、接口和抽象类的区别**

**实现**：抽象类的子类使用 extends 来继承；接口必须使用 implements 来实现接口。

**构造函数**：抽象类可以有构造函数；接口不能有。

**实现数量**：类可以实现很多个接口；但只能继承一个抽象类【java只支持单继承】。

**访问修饰符**：接口中的方法默认使用 public 修饰；抽象类中的抽象方法可以使用Public和Protected修饰。

接口中除了static、final变量，不能有其他变量，而抽象类中则不一定

**设计层面**：抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为的规范。

**62****、****springboot****注解**

一：ComponentScan ： 作用扫描

二：MapperScan ： 扫描mapper 

三：@SpringBootApplication 组合注解

四：@EnableAutoConfiguration 开启自动配置的功能

五：@AutoConfigurationPackage

@ImportAutoConfiguration 导入配置类，一般做测试的时候使用，正常优先使用@EnableAutoConfiguration 这

个注解是自动配置包

七：@Autowired 注入Service

@RestController``表示这是个控制器 bean 。

九：@ Configuration 一般用来声明配置类

@Service:

注解在类上，表示这是一个业务层bean

@Controller：注解在类上，表示这是一个控制层bean

@Repository:

注解在类上，表示这是一个数据访问层bean

@Component：

注解在类上，表示通用bean ，value不写默认就是类名首字母小写

@Transactional：事务注解

**63****、****springboot****不同环境怎么去配置**

这里我们有 3 个 properties 的配置文件，开发，测试环境，验证环境，生产环境。,还有 1 个 application.yml文

件,这个文件里有一个参数 spring.profiles.active 的选项,这个用来激活不同环境的配置.

**64****、数据库分页****oralce****分页语句**

select b.* from

(select rownum as rn_max,a.* from

(

需要分页的SQL语句结果集

) a

where rownum <= 当前页数*每页条数

) b where b.rn_max > (当前页数-1) * 每页条数

**65****、****js****的使用获取一个参数**

使用document.getElementById或者使用location.href，在进行参数遍历。

**66****、****linux****的常用命令**

**常用指令**

ls     显示文件或目录

   -l      列出文件详细信息l(list)

   -a      列出当前目录下所有文件及目录，包括隐藏的a(all)

mkdir     创建目录

   -p      创建目录，若无父目录，则创建p(parent)

cd        切换目录

touch      创建空文件

echo       创建带有内容的文件。

cat        查看文件内容

cp         拷贝mv        移动或重命名

rm        删除文件

   -r       递归删除，可删除子目录及文件

   -f       强制删除

find        在文件系统中搜索某文件

wc         统计文本中行数、字数、字符数

grep       在文本文件中查找某个字符串

rmdir      删除空目录

tree       树形结构显示目录，需要安装tree包

pwd        显示当前目录

ln          创建链接文件

more、less  分页显示文本文件内容

head、tail   显示文件头、尾内容

kill杀进程

tar添加压缩包

compress压缩

gunzip压缩

**67****、存储过程相关**

存储过程是一个预编译的SQL语句，优点是允许模块化的设计，就是说只需创建一次，以后在该程序中就可以调用

多次。

优点：

1）存储过程是预编译过的，执行效率高。

2）存储过程的代码直接存放于数据库中，通过存储过程名直接调用，减少网络通讯。

3）安全性高，执行存储过程需要有一定权限的用户。

4）存储过程可以重复使用，可减少数据库开发人员的工作量。

**68****、****jvm****参数配置。有没有做过，**

配置过，主要配置应用堆内存大小，gc日志，OOM后的dump数据收集。

在启动脚本，增加如下启动参数

**启动脚本增加****gc****日志输出，路径自定义目录即可。**

**注意避免多个服务进程日志覆盖。**

-Xloggc:/usr/logs/gc/tomcat_gc_ date +%Y-%m-%d .log**增加堆内存大小**

-Xms4096m -Xmx4096m

**添加****OOM****后生成****Dump****文件**

-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/usr/logs/dump

启动G1收集器，它会从内存中删除垃圾对象

-XX:+UseG1GC 

**加快随机数产生过程，解决服务启动慢的问题**

-Djava.security.egd=file:/dev/./urandom

**69****、****GC****方面，怎么查看****jvm****的****gc****，生产上怎么看**

使用jstat命令查看jvm的gc情况

类加载统计：jstat -class pid

垃圾回收统计：jstat -gc pid

堆内存统计：jstat -gccapacity pid

新生代垃圾回收统计：jstat -gcnew pid

新生代内存统计：jstat -gcnewcapacity pid

老年代垃圾回收统计：jstat -gcold pid

老年的内存统计：jstat -gcoldcapacity pid

**70****、生产上什么服务器。部署方式。**

生产部署模式为Linux虚拟机，部署方式通过行里自动化投产工具CI流水线，Jekins，Devops进行增量包部署方

式。

**71****、线程池，线程池的工作原理，优化**

随着CPU核数的越来越多，不可避免的利用多线程技术以充分利用其计算能力。所以，多线程技术是服务端开发人

员必须掌握的技术。线程的创建和销毁，都涉及到系统的调用，比较消耗系统资源，所以就引入了线程池技术，避

免线程频繁的创建和销毁。**事务隔离级别** 

**脏读** 

**不可重复读** 

**幻读**

读未提交（read-uncommitted） 

是 

是 

是

不可重复读（read-committed） 

否 

是 

是

可重复读（repeatable-read） 

否 

否 

是

串行化（serializable） 

否 

否 

否

当线程池中有任务需要执行时，线程池会判断如果线程数量没有超过核心数量就会新建线程池进行任务执行，如果

线程池中的线程数量已经超过核心线程数，这时候任务就会被放入任务队列中排队等待执行；如果任务队列超过最

大队列数，并且线程池没有达到最大线程数，就会新建线程来执行任务；如果超过了最大线程数，就会执行拒绝执

行策略。

**72****、结合业务常见，哪里使用过线程池**

结合自身情况回答，比如：1.在高并发请求场景下，使用异步线程池进行交易异步处理，达到流量削峰作用。2.在

工资批量代发任务中，使用线程池并行处理工资代发，提升处理效率。

**73****、****mysql****事务隔离级别有几种**

**74****、项目使用数据库，数据量多大**

结合自身情况回答，比如项目使用数据库有Oracle，Mysql，达梦，GoldenDB等，数据量从几十万到千万不等，

对于数据较大的数据表，会进行分区，分表，清理上带库策略。

**75****、分库分表，多数据库的项目**

分表：比如单表数据量太大，会极大影响你的 sql 执行的性能，到了后面你的 sql 可能就跑的很慢了。一般来说，

就是把一个表的数据放到多个表中，然后查询的时候你就查一个表。比如按照用户 id 来分表，将一个用户的数据

就放在一个表中。

分库：比如一个库一般我们经验而言，最多支撑到并发 2000，一定要扩容了，而且一个健康的单库并发值你最好

保持在每秒 1000 左右，不要太大。那么你可以将一个库的数据拆分到多个库中，访问的时候就访问一个库好了。

比较常见的分库分表中间件包括：cobar、TDDL、atlas、sharding-jdbc、mycat

**76****、存储过程**存储过程是一个预编译的SQL语句，优点是允许模块化的设计，就是说只需创建一次，以后在该程序中就可以调用

多次。

优点：

1）存储过程是预编译过的，执行效率高。

2）存储过程的代码直接存放于数据库中，通过存储过程名直接调用，减少网络通讯。

3）安全性高，执行存储过程需要有一定权限的用户。

4）存储过程可以重复使用，可减少数据库开发人员的工作量。

**77****、乐观锁，悲观锁**

乐观锁 ：假定没有冲突，在修改数据时如果发现数据和之前获取的不一致，则读最新数据，修改后重试修改。 例

如：CAS,db中可采采用版本号的方式;

悲观锁 ：假定会发生并发冲突，同步所有对数据的相关操作，从读数据就开始上锁。

**78****、有没有用过分布式架构**

根据自身使用情况进行描述，比如：主流的分布式技术除了SpringBoot/Cloud、Dubbo外，像腾讯的TSF，京东的

JSF，新浪的Motan等；SpringBoot/Cloud是国际性应用最广发的分布式框架技术；Dubbo是阿里巴巴开源的一个

RPC（远程过程调用）架构。

**79****、业务怎么拆分服务**

根据业务场景的不同特性拆分不同的服务，使其更加独立 ，方便后续维护和横向扩展。

**80****、业务之间通讯采用什么协议**

HTTP协议是典型的通讯模式，由客户端主动发起连接，向服务器请求XML或JSON数据,服务端接收到请求之后给出

相应的响应结果

**81****、有用过什么微服务框架吗**

根据自身使用情况进行描述，比如：Spring Cloud，Dubbo

**82****、有用过什么缓存中间件吗**

根据自身使用情况进行描述，比如Redis，Mencached，Ehcache

**83****、****redis****怎么部署**

举例:redis cluster，10 台机器，5 台机器部署了 redis 主实例，另外 5 台机器部署了 redis 的从实例，每个主实例

挂了一个从实例，5 个节点对外提供读写服务，每个节点的读写高峰qps可能可以达到每秒 5 万，5 台机器最多是

25 万读写请求/s

**84****、****reids****的雪崩，穿透等场景**

雪崩:一般redis的数据都是有过期时间。当大量的数据在同一时间失效，此时大量的用户请求就会直接请求我们的

数据库，此时就有可能将我们的数据库打崩

设置缓存的随机失效穿透:一般是出现这种情况是因为恶意频繁查询才会对系统造成很大的问题: key缓存并且数据库不存在，所以每次

查询都会查询数据库从而导致数据库崩溃

使用布隆过滤器;或者增加对热点缓存数据不设置过期时间,由业务层进行过期处理.

**85****、有没有做过高并发的项目**

结合自己项目经验进行回答；

**86****、怎么保持高并发**

接口层采用降级策略;接口调用方采用熔断策略,保证服务的高可用,针对使用检索高频的接口看业务情况使用缓存策

略,加快接口响应,针对于链路调用过长的业务采用异步削峰的方式.

**87****、遇到什么技术难题，自己是怎么解决的**

三个原则，重要性从高到低：

1、不能耽搁项目进度（不行设法绕过）；

2、尽量不要占用他人时间；

3、不能轻易放过（有时间时要研究透彻）

解决方案：分析技术实现业务场景，确认技术选型，通过互联网资料分析或公司技术专家支持，对问题进行解决；

**88****、分布式事务锁**

分布式锁，是指在分布式的部署环境下，通过锁机制来让多客户端互斥的对共享资源进行访问。

排他性：在同一时间只会有一个客户端能获取到锁，其它客户端无法同时获取

避免死锁：这把锁在一段有限的时间之后，一定会被释放（正常释放或异常释放）

高可用：获取或释放锁的机制必须高可用且性能佳

**89****、同步交易和异步交易**

**同步交易**：指发出一个请求后，需要等待返回，才能进行下一个请求触发，有个等待的过程。

**异步交易**：指发出一个请求后，不需要等待返回，随时可以触发下一个请求，不需要等待。

**区别**：一个需要等待，一个不需要等待，在部分情况下、有的项目开发中都会优先选择不需要等待的异步交互方

式。

**90****、异步交易的例子**

常用案例为下单减库存，高并发单账户出金入金，当用户请求时，只记录请求信息，同时提交业务请求到异步线程

池或消息队列，进行后续业务出金，入金。并提供查证接口给调用方，来确认该笔业务是否成功。

**91****、****Linux****常用命令，查看日志**

**常用指令**

ls     显示文件或目录

   -l      列出文件详细信息l(list)   -a      列出当前目录下所有文件及目录，包括隐藏的a(all)

mkdir     创建目录

   -p      创建目录，若无父目录，则创建p(parent)

cd        切换目录

touch      创建空文件

echo       创建带有内容的文件。

cat        查看文件内容

cp         拷贝

mv        移动或重命名

rm        删除文件

   -r       递归删除，可删除子目录及文件

   -f       强制删除

find        在文件系统中搜索某文件

wc         统计文本中行数、字数、字符数

grep       在文本文件中查找某个字符串

rmdir      删除空目录

tree       树形结构显示目录，需要安装tree包

pwd        显示当前目录

ln          创建链接文件

more、less  分页显示文本文件内容

head、tail   显示文件头、尾内容

kill杀进程

tar添加压缩包

compress压缩

gunzip压缩

tail -n100 aaa.log //查询最后100行日志

**cat -n test.log |grep "debug"  //****查询关键字的日志**

less //分页查看日志

**92****、用过哪些集合类**

常用到的集合有 Set、List、Map。其中set和list继承了collection接口。

**93****、用到哪些****List**ArrayList：默认初始化长度为 10，扩容规则为 0.5倍的原容量加1，即一次扩容后的长度为 16，查询速度快，添

加、删除相对于LinkedList较慢、线程不同步(不安全)

LinkedList：默认初始化长度为 10，扩容规则为 0.5倍的原容量加1，即一次扩容后的长度为 16，查询速度快，添

加、删除相对于LinkedList较慢、线程不同步(不安全)

Vector：默认初始化长度为 10，扩容加载因子为 1，当元素长度大于原容量时进行扩容，默认为 10，一次扩容后

容量为 20；

特点：线程安全，但是速度慢；在实现的方法上，用 synchronized 关键字进行了修饰，即在方法上实现了同步

锁。

**94****、****ArrayList****和****LinkList****区别**

1.ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。

2.对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。

3.对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。

**95****、用过哪些****map**

经常用的是HashMap和Hashtable

高性能且线程安全的CurrentHashMap

**96****、用没有用过带顺序的****map**

Hashmap和Hashtable 都不是有序的。

TreeMap和LinkedHashmap都是有序的。（TreeMap默认是key升序，LinkedHashmap默认是数据插入顺序）

TreeMap是基于比较器Comparator来实现有序的。

LinkedHashmap是基于链表来实现数据插入有序的。

**97****、****HashMap****工作原理**

首先HashMap是非线程安全的。HashMap是基于hash原理的。经过put()和get()方法得到和存储对象。当进行

put()方法时，先经过key的hashCode()方法计算出hashCode，经过indexFor(hashCode,length)方法获得对象存储

于table中的下标位置，也就是找到bucked的位置用来存储Entry。

**98****、****HashMap****什么时候开始扩充**

当hashmap中的元素个数size超过数组长度*loadFactor*时，就会进行数组扩容，*loadFactor*的默认值为*0.75*，也就

是说，默认情况下，数组大小为*16*，那么当*hashmap*中元素个数超过*16*0.75=12的时候，就把数组的大小扩展为

2*16=32，即扩大一倍，然后重新计算每个元素在数组中的位置。

**99****、****sql****，****union** **和** **union all****什么区别**

union：对两个结果集进行并集操作，不包括重复行，同时进行默认规则的排序；

union All：对两个结果集进行并集操作，包括重复行，不进行排序；

**100****、****sql****用过哪些函数**

SUM，AVG，COUNT，FIRST，LAST，MAX，MIN，TO_DATE，TO_CHAR，TRIM，LAPD , HAVING**101****、****join** **和** **left join****区别**

join等价于inner join内连接抄，是返回两个表中都有的符合条件的行。

left join左连接，是返回左袭表知中所有的行及右表中符合条件的行。

right join右连接，是返回右表中所有的行及左表中符合条件的行。

full join全连接，是返回左表中所有的行及右表中所有的行，并按条件连接。

通常情况下，left join肯定比inner join返回的行数多道。

**102****、****sql****性能有什么注意事项**

1.查询的模糊匹配

   尽量避免在一个复杂查询里面使用 LIKE '%parm1%'—— 红色标识位置的百分号会导致相关列的索引无法使用，

最好不要用.

解决办法:

其实只需要对该脚本略做改进，查询速度便会提高近百倍。改进方法如下：

​    a、修改前台程序——把查询条件的供应商名称一栏由原来的文本输入改为下拉列表，用户模糊输入供应商名

称时，直接在前台就帮忙定位到具体的供应商，这样在调用后台程序时，这列就可以直接用等于来关联了。

​    b、直接修改后台——根据输入条件，先查出符合条件的供应商，并把相关记录保存在一个临时表里头，然后

再用临时表去做复杂关联

2.索引问题

​    在做性能跟踪分析过程中，经常发现有不少后台程序的性能问题是因为缺少合适索引造成的，有些表甚至一个

索引都没有。这种情况往往都是因为在设计表时，没去定义索引，而开发初期，由于表记录很少，索引创建与否，

可能对性能没啥影响，开发人员因此也未多加重视。然一旦程序发布到生产环境，随着时间的推移，表记录越来越

多，这时缺少索引，对性能的影响便会越来越大了。

法则：不要在建立的索引的数据列上进行下列操作:

避免对索引字段进行计算操作

避免在索引字段上使用not，<>，!=

避免在索引列上使用IS NULL和IS NOT NULL 

避免在索引列上出现数据类型转换

避免在索引字段上使用函数

避免建立索引的列中使用空值。

3.不要把SQL语句写得太复杂

超过3层嵌套，查询优化器就很容易给出错误的执行计划

另外，执行计划是可以被重用的，越简单的SQL语句被重用的可能性越高。而复杂的SQL语句只要有一个字符发生

变化就必须重新解析，然后再把这一大堆垃圾塞在内存里。可想而知，数据库的效率会何等低下。

4.选择最有效率的表名顺序

FROM子句中写在最后的表(基础表 driving table)将被最先处理在FROM子句中包含多个表的情况下,你必须选择记录条数最少的表作为基础表。如果有3个以上的表连接查询, 那就

需要选择交叉表(intersection table)作为基础表, 交叉表是指那个被其他表所引用的表

5.注意使用DISTINCT

在没有必要时不要用，它同UNION一样会使查询变慢。重复的记录在查询里是没有问题的

6.注意Select COUNT(*)

Select COUNT(*)的效率教低，尽量变通他的写法，而EXISTS快.同时请注意区别： select count(Field of null)

from Table 和 select count(Field of NOT null) from Table 的返回值是不同的

**103****、****cookie****和****session****有什么区别**

在客户端和服务端，cookie和session都是会话技术，cookie数据是存储到客户端，而session是存储到服务端

cookie安全性差，可以通过拦截或本地文件可以对cookie进行攻击；而session运行在服务端，安全性高

如果浏览器禁用了cookie，那么cookie就不能使用，而session不能禁用